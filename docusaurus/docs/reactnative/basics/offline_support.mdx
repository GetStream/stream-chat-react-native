---
id: offline-support
sidebar_position: 4
title: Offline Support
---

Stream Chat for React Native enables offline support by exposing a class called `StreamCache`. This allows using any storage provider with Stream.
The constructor requires a client, a `cacheInterface` object containing `getItem`, `setItem` and `removeItem` properties and a
token or token provider function. `cacheMedia` param is not required and defaults to true.

:::info

Please have in mind that we don't encrypt the data or block the access to the folder where images are stored.
Once the set/get functions are provided to the `StreamCache` singleton, you should implement the data encryption in there when needed.
Also, we store the cached media in the `DocumentDirectoryPath`, which other apps dont have access by default but this 
can be changed on application level, so please make sure you're not allowing other apps to access your `DocumentDirectoryPath`.

:::

## Creating a cache interface

First, create the `cacheInterface` object.

```ts

import AsyncStorage from '@react-native-community/async-storage';
import { CacheKeys, CacheValues } from 'stream-chat-react-native';

// Your custom types
import type {
  LocalAttachmentType,
  LocalChannelType,
  LocalCommandType,
  LocalEventType,
  LocalMessageType,
  LocalReactionType,
  LocalUserType,
  LoginConfig,
} from '../types';

const cacheInterface: CacheInterface<
      LocalAttachmentType,
      LocalChannelType,
      LocalCommandType,
      LocalMessageType,
      LocalReactionType,
      LocalUserType
    > = {
      getItem: (key) => AsyncStore.getItem(key, null),
      removeItem: (key) => AsyncStore.removeItem(key),
      setItem: (key, value) => AsyncStore.setItem(key, value),
    };

```

### Cache interface with synchronous storage providers

Once we need to support both synchronous and asynchronous storage providers, you need to wrap the return values of your cache 
interface into promises.

```ts

import { MMKV } from 'react-native-mmkv';
import { CacheKeys, CacheValues } from 'stream-chat-react-native';

// Your custom types
import type {
  LocalAttachmentType,
  LocalChannelType,
  LocalCommandType,
  LocalEventType,
  LocalMessageType,
  LocalReactionType,
  LocalUserType,
  LoginConfig,
} from '../types';

const cacheInterface: CacheInterface<
      LocalAttachmentType,
      LocalChannelType,
      LocalCommandType,
      LocalMessageType,
      LocalReactionType,
      LocalUserType
    > = {
    getItem: (key) => {
        const value = MMKV.getString(key)

        if (!value) {
            return Promise.resolve(null);
        }

        return Promise.resolve(JSON.parse(value) as CacheValues[Key]);
    },
    removeItem: (key) => {
        return Promise.resolve(MMKV.delete(key));
    },
    setItem: (key, value) => {
        return Promise.resolve(MMKV.set(key, JSON.stringify(value)));
    },
};

```

## Initializing the client with cached data

Now, you need to initialize the cache. Please have in mind that you still need to handle authentication by yourself by passing a token or
a token provider function as third parameter. 

:::info

If you use tokens without expiration date, just store/retrieve the token from your storage provider and send it to StreamCache.

If you use tokens with expiration date, have a look at our client documentation on 
[how to refresh expired tokens](https://getstream.io/chat/docs/react-native/tokens_and_authentication/?language=javascript&q=authen#how-to-refresh-expired-tokens)

:::

```ts

...
import { CacheKeys, CacheValues, StreamCache } from 'stream-chat-react-native';

const client = StreamChat.getInstance(api_key) // Your current client setup
const cacheInterface = { /** Your cache interface, as described in previous step */ }

function App() {
    const [ready, setReady] = useState(false);

    const initializeApp = useCallback(async () => {
        const config = // Your logics to get auth data
        const cacheInstance = StreamCache.getInstance(client, cacheInterface, config.userToken);

        if (await cacheInstance.hasCachedData()) {
            console.info('Found cached data. Initializing cache...');
            // initialize already takes care of calling connectUser internally
            await cacheInstance.initialize();
        } else {
            console.info('No cache data found. Skipping cache initialization...');

            const user = {
                id: config.userId,
                image: config.userImage,
                name: config.userName,
            };

            // In case there is no cache, you need to authenticate by calling connectUser.
            await client.connectUser(user, config.userToken);
        }
    }, [])

    useEffect(() => {
        initializeApp(config);
    }, [])

    return ready && (
        <Chat client={client}>
          // Stream chat components
        </Chat>
    );
}

```

## Clearing cache

If you want to clear the cache, you can just call `StreamCache.getInstance().clear()` or `StreamMediaCache.clear()` in case 
you only want to clear cached media. StreamCache's clear method already takes care of clearing the StreamMediaCache.

## Custom components & offline support

If you're using your own custom components/hooks, you may need to pay attention to check if you're customizing any of the key
components/hooks we use to make the offline support work. In order to make things easier for you, the package is exposing some
lower level methods and components that you can easily use in order to make your components work offline.

:::note

If you're not adding customizations to any of the following components/hooks, please ignore this step.

:::

### usePaginatedChannel

Not a component, but if you're using your own hook to fetch the `channel list` items, you may need to have a look at our
[usePaginatedChannel](https://github.com/GetStream/stream-chat-react-native/blob/develop/package/src/components/ChannelList/hooks/usePaginatedChannels.ts) hook. The secret is basically adding an `useEffect` with your channels as dependency so you can
update the stored channels order everytime it changes.

```ts

    const cacheInstance = StreamCache.hasInstance()
    ? StreamCache.getInstance()
    : null;

    // If cache is instantiated, get ordered channels from it. Otherwise use empty array.
    const [channels, setChannels] = useState(() =>
        cacheInstance ? cacheInstance.getOrderedChannels(filters, sort) : [],
    );

    // If cache is instantiated, update channels cached order everytime channels array changes.
    useEffect(() => {
        if (cacheInstance) {
        cacheInstance.syncChannelsCachedOrder(channels, filters, sort);
        }
  }, [channels]);

```

Also, its a good idea to call `cacheInstance.syncCacheAndImages()` every time you refresh your channel list
in order to remove cached images from older messages. This helps StreamCache to avoid huge cache objects and
possible memory overflow problems.

### Attachments `Image`

Our attachment components use React Native's default Image component to render image attachments
in the chat. If you're adding any kind of customizations to the attachments, please have in mind that
you're supposed to replace all `Images` with our `CachedAttachmentImage`.

### Gallery `ImageBackground`

Our gallery components use React Native's default ImageBackground component internally. If you've made
any kind of customizations to the gallery, please have in mind that you should replace your `ImageBackground`
component with our `CachedImageBackground`.

## StreamCache

A singleton used to manipulate Stream's cache in the application. It supports any cache storage provider and uses 
some methods from StreamMediaCache in order to keep the media cache up-to-date with the data cache.

### getInstance

This method gets the existent instance of StreamCache. If it doesnt exists, the method will initialize the
instance. Note that if you're initializing the instance, you need to provide the `client`, `cacheInterface` 
and `tokenOrProvider` parameters as explained in previous sections. 

### hasInstance

Used to check if StreamCache is initialized. This is useful when you want to conditionally load things from
cache only when it is active.

### hasCachedData

Used to check if StreamCache has cached data. This is useful when initializing the application and you need
to manually authenticate if there is no cached data.

### shouldCacheMedia

Used to check if StreamCache should cache media. This is useful when you want to create your own image component
and want it to be controlled by the StreamCache. The value is always the same as the `cacheMedia` value provided
when instantiating StreamCache.

### syncCacheAndImages

Syncs the cached data with the current client state. It will also remove cached images from channels/messages
that got removed when syncing the data.

### initialize

Initializes the client with data from cache.

### getOrderedChannels

Get the list of cached channels ordered with the last saved channels order. This is based on 
`filter` and `sort` parameters.

### syncChannelsCachedOrder

Syncs the channels order based on the `filter` and `sort` parameters.

### clear

Clears all cached data. This is useful when you're unauthenticating and want to remove the user's cached data.

## StreamMediaCache

In case you want to manipulate the media caching manually, the package exposes an object called `StreamMediaCache`
which exposes the methods we use for storing/retrieving media from the file system.

### checkIfLocalAttachment,

Used to check if attachment exists in file system cache.

### checkIfLocalAvatar,

Used to check if avatar exists in file system cache.

### clear

Clears the whole Stream's file system cache.

### getStreamChannelAvatarDir

Given a channelId and fileUrl, it returns the path where the cached avatar should be stored.

### getStreamChannelMessageAttachmentDir

Given a channelId and messageId, it returns the path where the cached attachment should be stored.

### removeChannelAttachments

Given a channelId, clears the cached attachments related to that channel.

### removeChannelAvatars

Given a channelId, clears the cached avatars related to that channel.

### removeMessageAttachments

Given a channelId and a messageId, clears the attachments related to that message.

### saveAttachment

Given a channelId, messageId, fileId and fileUrl, saves the attachment in the file system.

### saveAvatar

Given a channelId, fileId and fileUrl, saves the avatr in the file system.